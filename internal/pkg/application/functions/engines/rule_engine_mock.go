// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package engines

import (
	"context"
	"github.com/diwise/iot-core/internal/pkg/infrastructure/database/rules"
	"github.com/diwise/iot-core/pkg/messaging/events"
	"github.com/diwise/senml"
	"sync"
)

// Ensure, that RuleEngineMock does implement RuleEngine.
// If this is not the case, regenerate this file with moq.
var _ RuleEngine = &RuleEngineMock{}

// RuleEngineMock is a mock implementation of RuleEngine.
//
//	func TestSomethingThatUsesRuleEngine(t *testing.T) {
//
//		// make and configure a mocked RuleEngine
//		mockedRuleEngine := &RuleEngineMock{
//			ValidationResultsFunc: func(ctx context.Context, msg events.MessageReceived) ([]RuleValidation, error) {
//				panic("mock out the ValidationResults method")
//			},
//			ValidateRecordFunc: func(record senml.Record, rule rules.Rule) RuleValidation {
//				panic("mock out the ValidateRecord method")
//			},
//		}
//
//		// use mockedRuleEngine in code that requires RuleEngine
//		// and then make assertions.
//
//	}
type RuleEngineMock struct {
	// ValidationResultsFunc mocks the ValidationResults method.
	ValidationResultsFunc func(ctx context.Context, msg events.MessageReceived) ([]RuleValidation, error)

	// ValidateRecordFunc mocks the ValidateRecord method.
	ValidateRecordFunc func(record senml.Record, rule rules.Rule) RuleValidation

	// calls tracks calls to the methods.
	calls struct {
		// ValidationResults holds details about calls to the ValidationResults method.
		ValidationResults []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Msg is the msg argument value.
			Msg events.MessageReceived
		}
		// ValidateRecord holds details about calls to the ValidateRecord method.
		ValidateRecord []struct {
			// Record is the record argument value.
			Record senml.Record
			// Rule is the rule argument value.
			Rule rules.Rule
		}
	}
	lockValidationResults sync.RWMutex
	lockValidateRecord          sync.RWMutex
}

// ValidationResults calls ValidationResultsFunc.
func (mock *RuleEngineMock) ValidationResults(ctx context.Context, msg events.MessageReceived) ([]RuleValidation, error) {
	if mock.ValidationResultsFunc == nil {
		panic("RuleEngineMock.ValidationResultsFunc: method is nil but RuleEngine.ValidationResults was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Msg events.MessageReceived
	}{
		Ctx: ctx,
		Msg: msg,
	}
	mock.lockValidationResults.Lock()
	mock.calls.ValidationResults = append(mock.calls.ValidationResults, callInfo)
	mock.lockValidationResults.Unlock()
	return mock.ValidationResultsFunc(ctx, msg)
}

// ValidationResultsCalls gets all the calls that were made to ValidationResults.
// Check the length with:
//
//	len(mockedRuleEngine.ValidationResultsCalls())
func (mock *RuleEngineMock) ValidationResultsCalls() []struct {
	Ctx context.Context
	Msg events.MessageReceived
} {
	var calls []struct {
		Ctx context.Context
		Msg events.MessageReceived
	}
	mock.lockValidationResults.RLock()
	calls = mock.calls.ValidationResults
	mock.lockValidationResults.RUnlock()
	return calls
}

// ValidateRecord calls ValidateRecordFunc.
func (mock *RuleEngineMock) ValidateRecord(record senml.Record, rule rules.Rule) RuleValidation {
	if mock.ValidateRecordFunc == nil {
		panic("RuleEngineMock.ValidateRecordFunc: method is nil but RuleEngine.ValidateRecord was just called")
	}
	callInfo := struct {
		Record senml.Record
		Rule   rules.Rule
	}{
		Record: record,
		Rule:   rule,
	}
	mock.lockValidateRecord.Lock()
	mock.calls.ValidateRecord = append(mock.calls.ValidateRecord, callInfo)
	mock.lockValidateRecord.Unlock()
	return mock.ValidateRecordFunc(record, rule)
}

// ValidateRecordCalls gets all the calls that were made to ValidateRecord.
// Check the length with:
//
//	len(mockedRuleEngine.ValidateRecordCalls())
func (mock *RuleEngineMock) ValidateRecordCalls() []struct {
	Record senml.Record
	Rule   rules.Rule
} {
	var calls []struct {
		Record senml.Record
		Rule   rules.Rule
	}
	mock.lockValidateRecord.RLock()
	calls = mock.calls.ValidateRecord
	mock.lockValidateRecord.RUnlock()
	return calls
}
