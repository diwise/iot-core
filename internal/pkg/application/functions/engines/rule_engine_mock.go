// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package engines

import (
	"context"
	"github.com/diwise/iot-core/internal/pkg/infrastructure/database/rules"
	"github.com/diwise/iot-core/pkg/messaging/events"
	"github.com/diwise/senml"
	"log/slog"
	"sync"
)

// Ensure, that RuleEngineMock does implement RuleEngine.
// If this is not the case, regenerate this file with moq.
var _ RuleEngine = &RuleEngineMock{}

// RuleEngineMock is a mock implementation of RuleEngine.
//
//	func TestSomethingThatUsesRuleEngine(t *testing.T) {
//
//		// make and configure a mocked RuleEngine
//		mockedRuleEngine := &RuleEngineMock{
//			ValidateMessageReceivedFunc: func(ctx context.Context, msg events.MessageReceived, logger *slog.Logger) ([]RuleValidation, error) {
//				panic("mock out the ValidateMessageReceived method")
//			},
//			ValidateRecordFunc: func(record senml.Record, rule rules.Rule, logger *slog.Logger) (RuleValidation, error) {
//				panic("mock out the ValidateRecord method")
//			},
//		}
//
//		// use mockedRuleEngine in code that requires RuleEngine
//		// and then make assertions.
//
//	}
type RuleEngineMock struct {
	// ValidateMessageReceivedFunc mocks the ValidateMessageReceived method.
	ValidateMessageReceivedFunc func(ctx context.Context, msg events.MessageReceived, logger *slog.Logger) ([]RuleValidation, error)

	// ValidateRecordFunc mocks the ValidateRecord method.
	ValidateRecordFunc func(record senml.Record, rule rules.Rule, logger *slog.Logger) (RuleValidation, error)

	// calls tracks calls to the methods.
	calls struct {
		// ValidateMessageReceived holds details about calls to the ValidateMessageReceived method.
		ValidateMessageReceived []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Msg is the msg argument value.
			Msg events.MessageReceived
			// Logger is the logger argument value.
			Logger *slog.Logger
		}
		// ValidateRecord holds details about calls to the ValidateRecord method.
		ValidateRecord []struct {
			// Record is the record argument value.
			Record senml.Record
			// Rule is the rule argument value.
			Rule rules.Rule
			// Logger is the logger argument value.
			Logger *slog.Logger
		}
	}
	lockValidateMessageReceived sync.RWMutex
	lockValidateRecord          sync.RWMutex
}

// ValidateMessageReceived calls ValidateMessageReceivedFunc.
func (mock *RuleEngineMock) ValidateMessageReceived(ctx context.Context, msg events.MessageReceived, logger *slog.Logger) ([]RuleValidation, error) {
	if mock.ValidateMessageReceivedFunc == nil {
		panic("RuleEngineMock.ValidateMessageReceivedFunc: method is nil but RuleEngine.ValidateMessageReceived was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Msg    events.MessageReceived
		Logger *slog.Logger
	}{
		Ctx:    ctx,
		Msg:    msg,
		Logger: logger,
	}
	mock.lockValidateMessageReceived.Lock()
	mock.calls.ValidateMessageReceived = append(mock.calls.ValidateMessageReceived, callInfo)
	mock.lockValidateMessageReceived.Unlock()
	return mock.ValidateMessageReceivedFunc(ctx, msg, logger)
}

// ValidateMessageReceivedCalls gets all the calls that were made to ValidateMessageReceived.
// Check the length with:
//
//	len(mockedRuleEngine.ValidateMessageReceivedCalls())
func (mock *RuleEngineMock) ValidateMessageReceivedCalls() []struct {
	Ctx    context.Context
	Msg    events.MessageReceived
	Logger *slog.Logger
} {
	var calls []struct {
		Ctx    context.Context
		Msg    events.MessageReceived
		Logger *slog.Logger
	}
	mock.lockValidateMessageReceived.RLock()
	calls = mock.calls.ValidateMessageReceived
	mock.lockValidateMessageReceived.RUnlock()
	return calls
}

// ValidateRecord calls ValidateRecordFunc.
func (mock *RuleEngineMock) ValidateRecord(record senml.Record, rule rules.Rule, logger *slog.Logger) (RuleValidation, error) {
	if mock.ValidateRecordFunc == nil {
		panic("RuleEngineMock.ValidateRecordFunc: method is nil but RuleEngine.ValidateRecord was just called")
	}
	callInfo := struct {
		Record senml.Record
		Rule   rules.Rule
		Logger *slog.Logger
	}{
		Record: record,
		Rule:   rule,
		Logger: logger,
	}
	mock.lockValidateRecord.Lock()
	mock.calls.ValidateRecord = append(mock.calls.ValidateRecord, callInfo)
	mock.lockValidateRecord.Unlock()
	return mock.ValidateRecordFunc(record, rule, logger)
}

// ValidateRecordCalls gets all the calls that were made to ValidateRecord.
// Check the length with:
//
//	len(mockedRuleEngine.ValidateRecordCalls())
func (mock *RuleEngineMock) ValidateRecordCalls() []struct {
	Record senml.Record
	Rule   rules.Rule
	Logger *slog.Logger
} {
	var calls []struct {
		Record senml.Record
		Rule   rules.Rule
		Logger *slog.Logger
	}
	mock.lockValidateRecord.RLock()
	calls = mock.calls.ValidateRecord
	mock.lockValidateRecord.RUnlock()
	return calls
}
