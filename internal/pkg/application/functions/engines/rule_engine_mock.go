// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package engines

import (
	"context"
	"github.com/diwise/iot-core/internal/pkg/infrastructure/database/rules"
	"github.com/diwise/iot-core/pkg/messaging/events"
	"github.com/diwise/senml"
	"log/slog"
	"sync"
)

// Ensure, that RuleEngineMock does implement RuleEngine.
// If this is not the case, regenerate this file with moq.
var _ RuleEngine = &RuleEngineMock{}

// RuleEngineMock is a mock implementation of RuleEngine.
//
//	func TestSomethingThatUsesRuleEngine(t *testing.T) {
//
//		// make and configure a mocked RuleEngine
//		mockedRuleEngine := &RuleEngineMock{
//			ShouldAbortFunc: func(ctx context.Context, msg events.MessageReceived, log *slog.Logger) bool {
//				panic("mock out the ShouldAbort method")
//			},
//			ValidateMessageReceivedFunc: func(ctx context.Context, msg events.MessageReceived, log *slog.Logger) ([]RuleValidation, error) {
//				panic("mock out the ValidateMessageReceived method")
//			},
//			ValidateRecordFunc: func(record senml.Record, rule rules.Rule, log *slog.Logger) (RuleValidation, error) {
//				panic("mock out the ValidateRecord method")
//			},
//		}
//
//		// use mockedRuleEngine in code that requires RuleEngine
//		// and then make assertions.
//
//	}
type RuleEngineMock struct {
	// ShouldAbortFunc mocks the ShouldAbort method.
	ShouldAbortFunc func(ctx context.Context, msg events.MessageReceived, log *slog.Logger) bool

	// ValidateMessageReceivedFunc mocks the ValidateMessageReceived method.
	ValidateMessageReceivedFunc func(ctx context.Context, msg events.MessageReceived, log *slog.Logger) ([]RuleValidation, error)

	// ValidateRecordFunc mocks the ValidateRecord method.
	ValidateRecordFunc func(record senml.Record, rule rules.Rule, log *slog.Logger) (RuleValidation, error)

	// calls tracks calls to the methods.
	calls struct {
		// ShouldAbort holds details about calls to the ShouldAbort method.
		ShouldAbort []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Msg is the msg argument value.
			Msg events.MessageReceived
			// Log is the log argument value.
			Log *slog.Logger
		}
		// ValidateMessageReceived holds details about calls to the ValidateMessageReceived method.
		ValidateMessageReceived []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Msg is the msg argument value.
			Msg events.MessageReceived
			// Log is the log argument value.
			Log *slog.Logger
		}
		// ValidateRecord holds details about calls to the ValidateRecord method.
		ValidateRecord []struct {
			// Record is the record argument value.
			Record senml.Record
			// Rule is the rule argument value.
			Rule rules.Rule
			// Log is the log argument value.
			Log *slog.Logger
		}
	}
	lockShouldAbort             sync.RWMutex
	lockValidateMessageReceived sync.RWMutex
	lockValidateRecord          sync.RWMutex
}

// ShouldAbort calls ShouldAbortFunc.
func (mock *RuleEngineMock) ShouldAbort(ctx context.Context, msg events.MessageReceived, log *slog.Logger) bool {
	if mock.ShouldAbortFunc == nil {
		panic("RuleEngineMock.ShouldAbortFunc: method is nil but RuleEngine.ShouldAbort was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Msg events.MessageReceived
		Log *slog.Logger
	}{
		Ctx: ctx,
		Msg: msg,
		Log: log,
	}
	mock.lockShouldAbort.Lock()
	mock.calls.ShouldAbort = append(mock.calls.ShouldAbort, callInfo)
	mock.lockShouldAbort.Unlock()
	return mock.ShouldAbortFunc(ctx, msg, log)
}

// ShouldAbortCalls gets all the calls that were made to ShouldAbort.
// Check the length with:
//
//	len(mockedRuleEngine.ShouldAbortCalls())
func (mock *RuleEngineMock) ShouldAbortCalls() []struct {
	Ctx context.Context
	Msg events.MessageReceived
	Log *slog.Logger
} {
	var calls []struct {
		Ctx context.Context
		Msg events.MessageReceived
		Log *slog.Logger
	}
	mock.lockShouldAbort.RLock()
	calls = mock.calls.ShouldAbort
	mock.lockShouldAbort.RUnlock()
	return calls
}

// ValidateMessageReceived calls ValidateMessageReceivedFunc.
func (mock *RuleEngineMock) ValidateMessageReceived(ctx context.Context, msg events.MessageReceived, log *slog.Logger) ([]RuleValidation, error) {
	if mock.ValidateMessageReceivedFunc == nil {
		panic("RuleEngineMock.ValidateMessageReceivedFunc: method is nil but RuleEngine.ValidateMessageReceived was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Msg events.MessageReceived
		Log *slog.Logger
	}{
		Ctx: ctx,
		Msg: msg,
		Log: log,
	}
	mock.lockValidateMessageReceived.Lock()
	mock.calls.ValidateMessageReceived = append(mock.calls.ValidateMessageReceived, callInfo)
	mock.lockValidateMessageReceived.Unlock()
	return mock.ValidateMessageReceivedFunc(ctx, msg, log)
}

// ValidateMessageReceivedCalls gets all the calls that were made to ValidateMessageReceived.
// Check the length with:
//
//	len(mockedRuleEngine.ValidateMessageReceivedCalls())
func (mock *RuleEngineMock) ValidateMessageReceivedCalls() []struct {
	Ctx context.Context
	Msg events.MessageReceived
	Log *slog.Logger
} {
	var calls []struct {
		Ctx context.Context
		Msg events.MessageReceived
		Log *slog.Logger
	}
	mock.lockValidateMessageReceived.RLock()
	calls = mock.calls.ValidateMessageReceived
	mock.lockValidateMessageReceived.RUnlock()
	return calls
}

// ValidateRecord calls ValidateRecordFunc.
func (mock *RuleEngineMock) ValidateRecord(record senml.Record, rule rules.Rule, log *slog.Logger) (RuleValidation, error) {
	if mock.ValidateRecordFunc == nil {
		panic("RuleEngineMock.ValidateRecordFunc: method is nil but RuleEngine.ValidateRecord was just called")
	}
	callInfo := struct {
		Record senml.Record
		Rule   rules.Rule
		Log    *slog.Logger
	}{
		Record: record,
		Rule:   rule,
		Log:    log,
	}
	mock.lockValidateRecord.Lock()
	mock.calls.ValidateRecord = append(mock.calls.ValidateRecord, callInfo)
	mock.lockValidateRecord.Unlock()
	return mock.ValidateRecordFunc(record, rule, log)
}

// ValidateRecordCalls gets all the calls that were made to ValidateRecord.
// Check the length with:
//
//	len(mockedRuleEngine.ValidateRecordCalls())
func (mock *RuleEngineMock) ValidateRecordCalls() []struct {
	Record senml.Record
	Rule   rules.Rule
	Log    *slog.Logger
} {
	var calls []struct {
		Record senml.Record
		Rule   rules.Rule
		Log    *slog.Logger
	}
	mock.lockValidateRecord.RLock()
	calls = mock.calls.ValidateRecord
	mock.lockValidateRecord.RUnlock()
	return calls
}
