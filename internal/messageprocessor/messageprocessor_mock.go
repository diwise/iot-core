// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package messageprocessor

import (
	"context"
	"github.com/diwise/iot-core/pkg/messaging/events"
	"sync"
)

// Ensure, that MessageProcessorMock does implement MessageProcessor.
// If this is not the case, regenerate this file with moq.
var _ MessageProcessor = &MessageProcessorMock{}

// MessageProcessorMock is a mock implementation of MessageProcessor.
//
//	func TestSomethingThatUsesMessageProcessor(t *testing.T) {
//
//		// make and configure a mocked MessageProcessor
//		mockedMessageProcessor := &MessageProcessorMock{
//			ProcessMessageFunc: func(ctx context.Context, msg events.MessageReceived) (*events.MessageAccepted, error) {
//				panic("mock out the ProcessMessage method")
//			},
//		}
//
//		// use mockedMessageProcessor in code that requires MessageProcessor
//		// and then make assertions.
//
//	}
type MessageProcessorMock struct {
	// ProcessMessageFunc mocks the ProcessMessage method.
	ProcessMessageFunc func(ctx context.Context, msg events.MessageReceived) (*events.MessageAccepted, error)

	// calls tracks calls to the methods.
	calls struct {
		// ProcessMessage holds details about calls to the ProcessMessage method.
		ProcessMessage []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Msg is the msg argument value.
			Msg events.MessageReceived
		}
	}
	lockProcessMessage sync.RWMutex
}

// ProcessMessage calls ProcessMessageFunc.
func (mock *MessageProcessorMock) ProcessMessage(ctx context.Context, msg events.MessageReceived) (*events.MessageAccepted, error) {
	if mock.ProcessMessageFunc == nil {
		panic("MessageProcessorMock.ProcessMessageFunc: method is nil but MessageProcessor.ProcessMessage was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Msg events.MessageReceived
	}{
		Ctx: ctx,
		Msg: msg,
	}
	mock.lockProcessMessage.Lock()
	mock.calls.ProcessMessage = append(mock.calls.ProcessMessage, callInfo)
	mock.lockProcessMessage.Unlock()
	return mock.ProcessMessageFunc(ctx, msg)
}

// ProcessMessageCalls gets all the calls that were made to ProcessMessage.
// Check the length with:
//
//	len(mockedMessageProcessor.ProcessMessageCalls())
func (mock *MessageProcessorMock) ProcessMessageCalls() []struct {
	Ctx context.Context
	Msg events.MessageReceived
} {
	var calls []struct {
		Ctx context.Context
		Msg events.MessageReceived
	}
	mock.lockProcessMessage.RLock()
	calls = mock.calls.ProcessMessage
	mock.lockProcessMessage.RUnlock()
	return calls
}
